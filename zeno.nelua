## pragmas.nogc = 1

require 'io'
require 'arg'
require 'sequence'
require 'C.ctype'
require 'iterators'
require 'filestream'
require 'stringbuilder'
require 'Allocators.default'

function string:trim_spaces_left()
  local result = self:subview()
  while #result > 0 and C.isspace(result[#result]) ~= 0 do result = result:subview(1, -2) end
  return result
end

function string:trim_spaces_right()
  local result = self:subview()
  while #result > 0 and C.isspace(result[1]) ~= 0 do result = result:subview(2) end
  return result
end

function string:trim_spaces()
  return self:trim_spaces_left():trim_spaces_right()
end

global Code_Kind = @enum{
  IDENTIFIER = 0,
  KEYWORD,
  INTEGER,
  FLOAT,
  STRING,
  TUPLE,
}

global Code_Data = @union{
  as_atom: string,
  as_tuple: sequence(pointer),
}

global Code = @record{
  location: uinteger,
  kind: Code_Kind,
  data: Code_Data,
}

function Code:__tostring(): string
  if self.kind ~= Code_Kind.TUPLE then return self.data.as_atom end
  local sb: stringbuilder
  sb:write("(")
  for i, code in ipairs(self.data.as_tuple) do
    sb:write(tostring((@*Code)(code)))
    if i ~= #self.data.as_tuple then sb:write(" ") end
  end
  sb:write(")")
  return sb:promote()
end

global function parse_code(s: string, p: uinteger, file: string): (*Code, uinteger)
  local indents: sequence(uinteger) <close>
  local implictness: sequence(boolean) <close>
  local codes: sequence(*Code) <close>
  while true do
    local start = p
    local newline_was_skipped = false
    local beginning_of_line = p
    while true do
      while p <= #s and C.isspace(s[p]) ~= 0 do
        if s[p] == string.byte('\n', 1) then
          newline_was_skipped = true
          beginning_of_line = p + 1
        end
        p = p + 1
      end
      if p <= #s and s[p] == string.byte(';', 1) then
        while p <= #s and s[p] ~= string.byte('\n', 1) do p = p + 1 end
        continue
      end
      break
    end
    if p > #s then break end

    local indent = p - beginning_of_line
    local first_exp_of_line = newline_was_skipped or start == 1

    if first_exp_of_line then
      if #indents == 0 or indent > indents[#indents] then indents:push(indent) end
      if s[p] ~= string.byte('(', 1) and s[p] ~= string.byte(')', 1) then
        implictness:push(true)
        local tuple = default_allocator:new(Code)
        tuple.kind = Code_Kind.TUPLE
        codes:push(tuple)
      end
    end

    start = p
    if s[p] == string.byte('(', 1) then
      p = p + 1
      implictness:push(false)
      local tuple = default_allocator:new(Code)
      tuple.kind = Code_Kind.TUPLE
      codes:push(tuple)
    elseif s[p] == string.byte(')', 1) then
      p = p + 1

      if #implictness > 0 and implictness[#implictness] then
        implictness:pop()
        if #codes > 1 then
          local popped = codes:pop()
          codes[#codes].data.as_tuple:push(popped)
        end
      end

      if #implictness == 0 then
        io.stderr:writef("%s[%d] You have an extraneous closing parenthesis.\n", file, start)
        return nilptr, p
      end
      implictness:pop()
      if #codes > 1 then
        local popped = codes:pop()
        codes[#codes].data.as_tuple:push(popped)
      end
    else
      while p <= #s and C.isspace(s[p]) == 0 and s[p] ~= string.byte('(', 1) and s[p] ~= string.byte(')', 1) and s[p] ~= string.byte(';', 1) do p = p + 1 end
      local identifier = default_allocator:new(Code)
      identifier.kind = Code_Kind.IDENTIFIER
      identifier.data.as_atom = s:subview(start, p - 1)
      if #codes > 0 then codes[#codes].data.as_tuple:push(identifier) else codes:push(identifier) end
    end

    local peek = p
    while peek <= #s and C.isspace(s[peek]) ~= 0 and s[peek] ~= string.byte('\n', 1) and s[peek] ~= string.byte(';', 1) do peek = peek + 1 end
    local last_exp_of_line = peek > #s or s[peek] == string.byte('\n', 1) or s[peek] == string.byte(';', 1)
    if last_exp_of_line then
      if #implictness > 0 and implictness[#implictness] then
        implictness:pop()
        if #codes > 1 then
          local popped = codes:pop()
          codes[#codes].data.as_tuple:push(popped)
        end
      end
    end

    if #implictness == 0 then break end
  end
  if #implictness ~= 0 then
    io.stderr:writef("%s[%d] You are missing a closing parenthesis.\n", file, p)
    return nilptr, p
  end
  check(#codes <= 1)
  local result: *Code
  if #codes > 0 then result = codes:pop() else result = nilptr end
  return result, p
end

global function repl()
  local file = "repl"
  while true do
    io.stdout:write("> ")
    local src <close> = io.stdin:read()
    local trimmed = src:trim_spaces()
    if trimmed == "quit" or trimmed == "exit" then break end
    local pos = 1
    while true do
      local code, next_pos = parse_code(src, pos, file)
      if code == nilptr then break end
      pos = next_pos
      print(code)
    end
  end
end

global function compile(file: string)
  local f <close>, error_msg, error_code = filestream.open(file)
  if error_msg ~= "" then
    io.stderr:writef("I failed to find \"%s\" on your drive. Maybe you need to quote the entire path?\n", file)
    return
  end
  local src <close> = f:read('a')
  local pos = 1
  while true do
    local code, next_pos = parse_code(src, pos, file)
    if code == nilptr then break end
    pos = next_pos
    print(code)
  end
end

if #arg == 0 then repl() else compile(arg[1]) end
